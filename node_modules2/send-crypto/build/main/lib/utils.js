"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBase64 = exports.fromBase64 = exports.fromUTF8String = exports.toUTF8String = exports.shuffleArray = exports.fromHex = exports.Ox = exports.toHex = exports.strip0x = void 0;
const base64 = __importStar(require("base64-js"));
/**
 * Remove 0x prefix from a hex string. If the input doesn't have a 0x prefix,
 * it's returned unchanged.
 *
 * @param hex The hex value to be prefixed.
 */
const strip0x = (hex) => {
    return hex.substring(0, 2) === "0x" ? hex.slice(2) : hex;
};
exports.strip0x = strip0x;
/**
 * Convert a Uint8Array to a hex string (with no "0x"-prefix).
 */
const toHex = (array) => array.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
exports.toHex = toHex;
/**
 * Add a 0x prefix to a hex value, converting to a string first. If the input
 * is already prefixed, it's returned unchanged.
 *
 * @param hexInput The hex value to be prefixed.
 */
const Ox = (hexInput, { prefix } = { prefix: "0x" }) => {
    let hexString = hexInput instanceof Uint8Array
        ? (0, exports.toHex)(hexInput)
        : typeof hexInput === "number"
            ? hexInput.toString(16)
            : hexInput;
    if (hexString.length % 2 === 1) {
        hexString = "0" + hexString;
    }
    return hexString.substring(0, 2) === prefix
        ? hexString
        : `${prefix}${hexString}`;
};
exports.Ox = Ox;
/**
 * Convert a hex string to a Uint8Array.
 */
const fromHex = (hexString) => {
    // Strip "0x" prefix.
    hexString = (0, exports.strip0x)(hexString);
    // Pad the hex string.
    if (hexString.length % 2) {
        hexString = "0" + hexString;
    }
    // Split the string into bytes.
    const match = hexString.match(/.{1,2}/g);
    if (!match) {
        return new Uint8Array();
    }
    // Parse each byte and create a Uint8Array.
    return new Uint8Array(match.map((byte) => parseInt(byte, 16)));
};
exports.fromHex = fromHex;
/**
 * https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array/12646864#12646864
 * Randomize array element order in-place.
 * Using Durstenfeld shuffle algorithm.
 */
const shuffleArray = (...arrayIn) => {
    const array = arrayIn.length === 1 && Array.isArray(arrayIn[0])
        ? arrayIn[0]
        : arrayIn;
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
};
exports.shuffleArray = shuffleArray;
const toUTF8String = (input) => {
    let TextDecoderConstructor = 
    // @ts-expect-error (window is not defined)
    (window || {}).TextDecoder || require("util").TextDecoder;
    const textDecoder = new TextDecoderConstructor();
    return textDecoder.decode(input);
};
exports.toUTF8String = toUTF8String;
const fromUTF8String = (input) => {
    let TextEncoderConstructor = 
    // @ts-expect-error (window is not defined)
    (window || {}).TextEncoder || require("util").TextEncoder;
    const textEncoder = new TextEncoderConstructor();
    return textEncoder.encode(input);
};
exports.fromUTF8String = fromUTF8String;
/**
 * Convert a base64 string to a Uint8Array.
 */
const fromBase64 = (base64String) => {
    return base64.toByteArray(base64String);
};
exports.fromBase64 = fromBase64;
const toBase64 = (input) => {
    return base64.fromByteArray(input);
};
exports.toBase64 = toBase64;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0RBQW9DO0FBRXBDOzs7OztHQUtHO0FBQ0ksTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFXLEVBQVUsRUFBRTtJQUMzQyxPQUFPLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzdELENBQUMsQ0FBQztBQUZXLFFBQUEsT0FBTyxXQUVsQjtBQUVGOztHQUVHO0FBQ0ksTUFBTSxLQUFLLEdBQUcsQ0FBQyxLQUFpQixFQUFVLEVBQUUsQ0FDL0MsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFEakUsUUFBQSxLQUFLLFNBQzREO0FBRTlFOzs7OztHQUtHO0FBQ0ksTUFBTSxFQUFFLEdBQUcsQ0FDZCxRQUFzQyxFQUN0QyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxFQUN2QixFQUFFO0lBQ1IsSUFBSSxTQUFTLEdBQ1QsUUFBUSxZQUFZLFVBQVU7UUFDMUIsQ0FBQyxDQUFDLElBQUEsYUFBSyxFQUFDLFFBQVEsQ0FBQztRQUNqQixDQUFDLENBQUMsT0FBTyxRQUFRLEtBQUssUUFBUTtZQUM5QixDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDdkIsQ0FBQyxDQUFDLFFBQVEsQ0FBQztJQUVuQixJ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